{"version":3,"sources":["../src/index.ts"],"sourcesContent":["import { inflateRaw } from \"pako\";\nimport { Deck, GameSetting, Player, Replay } from \"./dataStructures\";\n\nconst englishRegex: RegExp = /^[A-Za-z0-9_]*$/;\nconst headerLength: number = 10;\nconst decoder = new TextDecoder('utf-16');\nlet dataView: DataView;\nlet uint8Ary: Uint8Array;\n/**\n * Parse the entire replay to get a Replay object.\n * @param fileArrayBuffer provide the array buffer of age3Yrec file\n * @returns return a replay with game infos\n */\nexport function parseReplay(fileArrayBuffer: ArrayBuffer): Replay {\n    uint8Ary = inflateRaw(fileArrayBuffer.slice(headerLength));\n    dataView = new DataView(uint8Ary.buffer);\n    let position = 273;\n    let stringLength = readInt32(position);\n    const exeInfo = readString(position, stringLength);\n    let version: number = Number(exeInfo.split(' ')[1]);\n    let dictionary = scanAllFields();\n    let gameSetting: GameSetting = {\n        allowCheats: dictionary['gameallowcheats'],\n        blockade: dictionary['gameblockade'],\n        playerCount: dictionary['gamenumplayers'],\n        difficulty: dictionary['gamedifficulty'],\n        startingAge: dictionary['gamestartingage'],\n        endingAge: dictionary['gameendingage'],\n        isTreaty: dictionary['gamestartwithtreaty'],\n        allowTradeMonopoly: dictionary['gametrademonopoly'],\n        gameType: dictionary['gametype'],\n        mapCRC: dictionary['gamefilecrc'],\n        mapName: dictionary['gamefilename'],\n        mapSet: dictionary['gamefilenameext'],\n        freeForAll: dictionary['gamefreeforall'],\n        hostTime: dictionary['gamehosttime'],\n        koth: dictionary['gamekoth'],\n        latency: dictionary['gamelatency'],\n        mapSetName: dictionary['gamemapname'],\n        mapResource: dictionary['gamemapresources'],\n        radomSeed: dictionary['gamerandomseed'],\n        gameSpeed: dictionary['gamespeed'],\n    }\n\n    let players: Player[] = [];\n    for (let i = 1; i <= gameSetting.playerCount; i++) {\n        let player: Player = {\n            aiPersonality: dictionary[`gameplayer${i}aipersonality`],\n            avatarId: dictionary[`gameplayer${i}avatarid`],\n            civId: dictionary[`gameplayer${i}civ`],\n            civIsRandom: dictionary[`gameplayer${i}civwasrandom`],\n            clan: dictionary[`gameplayer${i}clan`],\n            color: dictionary[`gameplayer${i}color`],\n            explorerName: dictionary[`gameplayer${i}explorername`],\n            explorerSkinId: dictionary[`gameplayer${i}explorerskinid`],\n            handicap: dictionary[`gameplayer${i}handicap`],\n            homecityFileName: dictionary[`gameplayer${i}hcfilename`],\n            homecityLevel: dictionary[`gameplayer${i}hclevel`],\n            homecityName: dictionary[`gameplayer${i}homecityname`],\n            slotId: dictionary[`gameplayer${i}id`],\n            playerName: dictionary[`gameplayer${i}name`],\n            intialDecks: [],\n        }\n        players.push(player);\n    }\n\n    // intial decks\n    players.sort((a, b) => a.slotId - b.slotId);\n    let deckIndex: number = 0;\n    let allDecks = searchAllDecks();\n    for (let i = 0; i < players.length; i++) {\n        let intialDecks: Deck[] = [];\n        let previousDeckId: number = allDecks[0].deckId;\n        while (deckIndex < allDecks.length) {\n            if (allDecks[deckIndex].deckId < previousDeckId) {\n                break;\n            }\n            if (allDecks[deckIndex].deckName == '*') {\n                break;\n            }\n            intialDecks.push(allDecks[deckIndex]);\n            previousDeckId = allDecks[deckIndex].deckId;\n            deckIndex++;\n        }\n        while (deckIndex < allDecks.length) {\n            if (allDecks[deckIndex].deckId == 0) {\n                break;\n            }\n            deckIndex++;\n        }\n        players[i].intialDecks = intialDecks;\n    }\n\n    let replay: Replay = {\n        exeVersion: version,\n        setting: gameSetting,\n        players: players,\n    }\n\n    return replay;\n}\n\nfunction scanAllFields(): { [k: string]: any } {\n    let dictionary: { [k: string]: any } = {};\n    let position = 0;\n    let endPosition = 20000; // the position of the fields won't exceed this number\n    let skipCount: number = 0;\n    while (position < endPosition) {\n        let word = readString(position, 1);\n        if (englishRegex.test(word)) {\n            if (skipCount >= 4) {\n                let isNextWord = true;\n                let nextWordLength: number = readInt32(position - 4);\n                let nextWord = readString(position, nextWordLength);\n                for (let char of nextWord) {\n                    if (!englishRegex.test(char)) {\n                        isNextWord = false;\n                        break;\n                    }\n                }\n                if (isNextWord) {\n                    position += nextWord.length * 2;\n                    let dataType = readInt32(position);\n                    position += 4;\n                    let data: any;\n                    switch (dataType) {\n                        case 1:\n                            data = readFloat32(position);\n                            position += 4;\n                            dictionary[nextWord] = data;\n                            break;\n                        case 2:\n                            data = readInt32(position);\n                            position += 4;\n                            dictionary[nextWord] = data;\n                            break;\n                        case 5:\n                            let bool = readBool(position);\n                            position += 1;\n                            dictionary[nextWord] = bool;\n                            break;\n                        case 9:\n                            let stringLength = readInt32(position);\n                            if (stringLength > 100) {\n                                position -= 4;\n                                // if stringLength is very long, it's most likely not a field.\n                                break;\n                            }\n                            position += 4;\n                            let string = readString(position, stringLength);\n                            position += stringLength * 2;\n                            dictionary[nextWord] = string;\n                            break;\n                    }\n                } else {\n                    position += 2;\n                }\n                skipCount = 0;\n            } else {\n                position += 2;\n            }\n        } else {\n            position += 1;\n            skipCount += 1;\n        }\n    }\n    return dictionary;\n}\n\nfunction searchAllDecks(): Deck[] {\n    let decks: Deck[] = [];\n    let position = 0;\n    while (true) {\n        let currentDeckPosition: number = position;\n        let nextDeckOffset: number = readInt32(position);\n        position += 4;\n        let check: number = readInt32(position);\n        position += 4;\n        if (check != 5) {\n            // if check isn't 5, it's not a deck\n            position = searchDeck(position);\n            if (position == -1) break;\n            continue;\n        }\n        let deckId: number = readInt32(position);\n        position += 4;\n        let stringLength: number = readInt32(position);\n        position += 4;\n        let deckName: string = readString(position, stringLength);\n        position += stringLength * 2;\n        var gameId = readInt32(position);\n        position += 4;\n        var isDefault = readBool(position);\n        position += 1;\n        let unKnownBool = readBool(position);\n        position += 1;\n        var cardCount = readInt32(position);\n        position += 4;\n        let techIds: number[] = [];\n        for (let j = 0; j < cardCount; j++) {\n            let techId = readInt32(position);\n            techIds.push(techId);\n            position += 4;\n        }\n\n        let deck: Deck = {\n            deckName: deckName,\n            deckId: deckId,\n            gameId: gameId,\n            isDefault: isDefault,\n            cardCount: cardCount,\n            techIds: techIds,\n        };\n        decks.push(deck);\n        position = currentDeckPosition + nextDeckOffset + 6;\n    }\n    return decks;\n}\n\nfunction readString(position: number, length: number): string {\n    const end = position + length * 2;\n    const string = decoder.decode(dataView.buffer.slice(position, end));\n    return string\n}\n\nfunction readInt32(position: number): number {\n    const int32 = dataView.getInt32(position, true);\n    return int32\n}\n\nfunction readFloat32(position: number): number {\n    const float32 = dataView.getFloat32(position, true)\n    return float32;\n}\n\nfunction readBool(position: number): boolean {\n    const bool = dataView.getUint8(position);\n    return Boolean(bool);\n}\n\nfunction readInt8(position: number): number {\n    const int8 = dataView.getUint8(position)\n    return int8\n}\n\nfunction searchDeck(startIndex: number): number {\n    let position = startIndex;\n    while (position < uint8Ary.length) {\n        position = search(uint8Ary, [0x0, 0x0, 0x0, 0x44, 0x6b], position);\n        if (position == -1) break;\n        position += 9;\n        let int = readInt32(position);\n        if (int != 5) continue;\n        return position - 4;\n    }\n    return -1;\n}\n\nfunction search(array: Uint8Array, search: number[], fromIndex: number = 0): number {\n    const searchLen = search.length\n    const searchLast = search[searchLen - 1]\n    let index = array.indexOf(searchLast, fromIndex + searchLen - 1)\n\n    while (index !== -1) {\n        for (let i = searchLen - 1; i > 0; i--) {\n            if (search[i - 1] !== array[index - searchLen + i]) {\n                const searchIndex = search.lastIndexOf(array[index + 1])\n                const offset = searchIndex === -1 ? index + searchLen + 1 : index + searchLen - searchIndex\n                index = array.indexOf(searchLast, offset)\n                break;\n            }\n            if (i === 1) return index - searchLen + 1\n        }\n    }\n    return -1\n}"],"mappings":"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","names":["search"]}